---
import { joinPaths } from '@astrojs/internal-helpers/path'
import config from '@/blog.config'
import Comment from '@/components/comment/Comment.astro'
import { userSession } from '@/helpers/auth/session'
import { increaseViews, loadComments } from '@/helpers/comment/loader'

// This is a component which loads comments and renders it on server-side.
interface Props {
  commentKey: string
  title: string
}

const { commentKey, title } = Astro.props
const comments = await loadComments(Astro.session, commentKey, title, 0)

// Increase the PV in production environment.
const user = await userSession(Astro.session)
if (user === undefined || !user.admin) {
  await increaseViews(commentKey, title)
}
---

<div id="comments" class="comments pt-5">
  {
    comments != null
      ? (
      <>
        <div class="h5 mb-4 comment-total-count">
          评论 <small class="font-theme text-sm">({comments.count})</small>
        </div>
        <div id="respond" class="comment-respond mb-3 mb-md-4">
          <form method="post" action="/comments/new" id="commentForm" class="comment-form">
            <div class="comment-from-avatar flex-avatar">
              {user?.admin
              ? (
                <img
                  alt="头像"
                  src={joinPaths(import.meta.env.SITE, `/images/avatar/${user.id}.png`)}
                  src={joinPaths(import.meta.env.SITE, `/images/avatar/${user.id}.png`)}
                  class="avatar avatar-40 photo avatar-default"
                  height="40"
                  width="40"
                  decoding="async"
                />
              )
              : (
                <img
                  alt="头像"
                  src={joinPaths(import.meta.env.SITE, '/images/default-avatar.png')}
                  data-src={joinPaths(import.meta.env.SITE, '/images/default-avatar.png')}
                  class="avatar avatar-40 photo avatar-default"
                  height="40"
                  width="40"
                  decoding="async"
                />
              )}
            </div>
            <div class="comment-from-input flex-fill">
              <div class="comment-form-text mb-3">
                <textarea id="content" name="content" class="form-control" rows="3" required />
              </div>
              <div class="comment-form-info row g-2 g-md-3 mb-3">
                {user?.admin
                ? (
                  <input
                    class="form-control"
                    placeholder={user.name}
                    name="name"
                    type="text"
                    readonly
                    hidden
                    value={user.name}
                  />
                )
                : (
                  <div class="col">
                    <input class="form-control" placeholder="昵称" name="name" type="text" required />
                  </div>
                )}
                {user?.admin
                ? (
                  <input
                    class="form-control"
                    name="email"
                    placeholder={user.email}
                    value={user.email}
                    type="email"
                    readonly
                    hidden
                  />
                )
                : (
                  <div class="col-12 col-md-6">
                    <input class="form-control" name="email" placeholder="邮箱" type="email" required />
                  </div>
                )}
                <input hidden name="page_key" type="text" value={commentKey} />
                <input hidden name="rid" type="text" value="0" />
                {user?.admin
                ? (
                  <input
                    class="form-control"
                    placeholder={user.website}
                    value={user.website}
                    name="link"
                    type="url"
                    readonly
                    hidden
                  />
                )
                : (
                  <div class="col-12">
                    <input class="form-control" placeholder="网址" name="link" type="url" />
                  </div>
                )}
              </div>
              <div class="form-submit text-end">
                <input type="button" id="cancel-comment-reply-link" class="btn btn-light me-1" value="再想想" hidden />
                <input name="submit" type="submit" id="submit" class="btn btn-primary" value="发表评论" />
              </div>
            </div>
          </form>
        </div>
        <ul class="comment-list">
          <Comment comments={comments} session={Astro.session} />
        </ul>
        {config.settings.comments.size < comments.roots_count && (
          <div class="text-center mt-3 mt-md-4">
            <button
              id="comments-next-button"
              data-key={commentKey}
              data-size={config.settings.comments.size}
              data-offset={config.settings.comments.size}
              type="button"
              class="btn btn-light"
            >
              加载更多
            </button>
          </div>
        )}
      </>
    )
    : (
      '评论加载失败 ❌'
    )
  }
</div>

<script>
import { actions } from 'astro:actions'
import { handleActionError } from '@/assets/scripts/actions'

// Type helpers
type Nullable<T> = T | null

// Loading the comments.
const comments = document.querySelector<HTMLDivElement>('#comments')
if (typeof comments !== 'undefined' && comments !== null) {
  const cancel = comments.querySelector<HTMLInputElement>('#cancel-comment-reply-link')!
  const replyForm = comments.querySelector<HTMLDivElement>('#respond')!
  const cancelReply = (): void => {
    cancel.hidden = true;
    (replyForm.querySelector('textarea[name="content"]') as HTMLTextAreaElement).value = ''

    // Remove the readonly replying-to prefix or overlay if present and restore padding
    const replyingTo = replyForm.querySelector('.replying-to, .replying-to-overlay')
    if (replyingTo) {
      // If it's an overlay, restore textarea padding and remove event listeners
      if (replyingTo.classList.contains('replying-to-overlay')) {
        const formText = replyForm.querySelector<HTMLDivElement>('.comment-form-text')!
        const textarea = formText.querySelector<HTMLTextAreaElement>('textarea[name="content"]')!
        const orig = textarea.dataset._origPaddingTop || ''
        textarea.style.paddingTop = orig
        delete textarea.dataset._origPaddingTop

        // Remove attached handlers
        const onFocus = (textarea as any).__replyOverlayFocus
        const onBlur = (textarea as any).__replyOverlayBlur
        if (onFocus)
          textarea.removeEventListener('focus', onFocus)
        if (onBlur)
          textarea.removeEventListener('blur', onBlur)
        delete (textarea as any).__replyOverlayFocus
        delete (textarea as any).__replyOverlayBlur
      }
      replyingTo.remove()
    }

    // Move the form back to top.
    const commentCount = comments.querySelector('.comment-total-count')!
    commentCount.after(replyForm)

    // Get rid to clean up the children form.
    const ridInput = replyForm.querySelector<HTMLInputElement>('input[name="rid"]')!
    const rid = ridInput.value
    ridInput.value = '0'
    if (rid !== '0') {
      const userComment = comments.querySelector(`#user-comment-${rid}`) as Nullable<HTMLLIElement>
      if (userComment) {
        const children = userComment.querySelector('.children') as Nullable<HTMLUListElement>
        if (children !== null && children.querySelectorAll('li').length === 0) {
          children.remove()
        }
      }
    }
  }

  comments.addEventListener('focusout', (event: FocusEvent) => {
    const avatar = document.querySelector<HTMLImageElement>('#commentForm img.avatar')
    const emailInput = document.querySelector<HTMLInputElement>('input[name="email"]')
    if (event.target === emailInput && avatar && emailInput) {
      event.stopPropagation()
      const email = emailInput.value
      if (email !== '' && email.includes('@')) {
        // Replace the avatar after typing the email.
        actions.comment.findAvatar({ email }).then(({ data, error }: any) => {
          if (error) {
            return handleActionError(error)
          }
          avatar.src = data.avatar
        })
      }
      else {
        avatar.src = avatar.dataset.src!
      }
    }
  })

  comments.addEventListener('click', async (event: MouseEvent) => {
    const target = event.target as HTMLElement
    // Loading more comments from server.
    const nextButton = comments.querySelector('#comments-next-button')
    if (target === nextButton) {
      const btn = target as HTMLButtonElement
      // Disable button immediately to prevent duplicate triggers and show loading state.
      const originalText = btn.textContent || ''
      btn.disabled = true
      btn.textContent = '加载中...'

      const { size, offset, key } = btn.dataset
      if (typeof key === 'string' && typeof offset === 'string' && typeof size === 'string') {
        try {
          const { data, error } = await actions.comment.loadComments({ offset: Number(offset), page_key: key })
          if (error) {
            // Restore button state on error before delegating to the handler.
            btn.disabled = false
            btn.textContent = originalText
            return handleActionError(error)
          }

          const { content, next } = data

          // Append the comments into the list.
          if (content !== '') {
            btn.dataset.offset = String(Number(offset) + Number(size))
            comments.querySelector('.comment-list')!.insertAdjacentHTML('beforeend', content)
          }

          // Remove the load more button if no further pages, otherwise restore it.
          if (!next || content === '') {
            btn.remove()
          }
          else {
            btn.disabled = false
            btn.textContent = originalText
          }
        }
        catch (e) {
          // Network or unexpected error: restore button and rethrow/log.
          btn.disabled = false
          btn.textContent = originalText
          console.error(e)
        }
      }
      else {
        // If dataset is malformed, restore button state.
        btn.disabled = false
        btn.textContent = originalText
      }
    }

    // Reply a comment.
    if (target.matches('.comment-reply-link')) {
      cancelReply()
      cancel.hidden = false;
      (replyForm.querySelector('input[name="rid"]') as HTMLInputElement).value = (target as HTMLElement).dataset.rid!

      // Move form to the reply.
      const commentItem = target.closest('li') as HTMLLIElement
      if (commentItem.dataset.depth === '1') {
        if (commentItem.querySelector('ul.children') === null) {
          // Create this for better architecture.
          commentItem.insertAdjacentHTML('beforeend', '<ul class="children"></ul>')
        }
        commentItem.querySelector('ul.children')!.appendChild(replyForm)
      }
      else {
        commentItem.after(replyForm)
      }

      // Extract the author name and content from the comment
      let authorName = ''
      let originalContent = ''
      const authorEl = commentItem.querySelector('.comment-author') as HTMLElement | null
      const contentEl = commentItem.querySelector('.comment-content') as HTMLElement | null

      if (authorEl) {
        const anchor = authorEl.querySelector('a') as HTMLAnchorElement | null
        if (anchor && anchor.textContent) {
          authorName = anchor.textContent.trim()
        }
        else {
          const textNode = Array.from(authorEl.childNodes).find(n => n.nodeType === Node.TEXT_NODE && n.textContent && n.textContent.trim())
          authorName = (textNode && textNode.textContent) ? textNode.textContent.trim() : (authorEl.textContent || '').trim()
        }
      }

      if (contentEl) {
        originalContent = contentEl.textContent?.trim() || ''
      }

      // Remove any existing prefix/overlay then insert new one
      const existingPrefix = replyForm.querySelector('.replying-to, .replying-to-overlay')
      if (existingPrefix)
        existingPrefix.remove()
      if (authorName) {
        const formText = replyForm.querySelector<HTMLDivElement>('.comment-form-text')!
        const textarea = formText.querySelector<HTMLTextAreaElement>('textarea[name="content"]')!

        // Create an overlay element that floats inside the textarea area.
        const overlay = document.createElement('div')
        overlay.className = 'replying-to-overlay'

        // Create spans for the name and content parts for better styling
        const nameSpan = document.createElement('span')
        nameSpan.className = 'replying-name'
        nameSpan.textContent = `回复 @${authorName}`

        const contentSpan = document.createElement('span')
        contentSpan.className = 'replying-content'
        contentSpan.textContent = originalContent ? `: ${originalContent}` : ''

        overlay.appendChild(nameSpan)
        overlay.appendChild(contentSpan)
        Object.assign(overlay.style, {
          position: 'absolute',
          top: '0.4rem',
          left: '0.75rem',
          right: '0.75rem',
          fontSize: '0.9rem',
          color: 'rgba(73, 80, 87, 0.95)',
          pointerEvents: 'none',
          background: 'rgba(0, 140, 149, 0.05)',
          borderRadius: '4px',
          padding: '0.15rem 0.5rem',
          zIndex: '2',
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          opacity: '0.6',
          display: 'flex',
          gap: '0.25rem',
          alignItems: 'center',
        })

        // Ensure the container is positioned so the overlay can be absolutely positioned.
        const formTextEl = formText as HTMLElement
        if (!formTextEl.style.position)
          formTextEl.style.position = 'relative'

        // Remember original textarea paddingTop for later restore.
        const prevPaddingTop = textarea.style.paddingTop || window.getComputedStyle(textarea).paddingTop || ''
        textarea.dataset._origPaddingTop = prevPaddingTop

        // Append overlay first so we can measure its height and set a padding gap
        formText.appendChild(overlay)

        // Compute overlay height and add a small gap so the caret doesn't collide with overlay.
        // Use getBoundingClientRect with fallback to offsetHeight.
        const overlayRect = overlay.getBoundingClientRect()
        const overlayHeight = (overlayRect && overlayRect.height) ? overlayRect.height : (overlay.offsetHeight || 0)
        const gap = 10 // px gap between overlay bottom and caret
        textarea.style.paddingTop = `${overlayHeight + gap}px`
      }

      // Focus the comment form.
      (replyForm.querySelector('#content') as HTMLTextAreaElement).focus()
    }

    // Edit a comment (admin only visible button)
    if (target.matches('.comment-edit-link')) {
      const rid = (target as HTMLElement).dataset.rid
      if (typeof rid === 'string') {
        const commentItem = target.closest('li') as HTMLLIElement
        const contentEl = commentItem.querySelector('.comment-content') as HTMLElement | null
        if (!contentEl)
          return

        // Prevent duplicate editors
        if (commentItem.querySelector('.comment-edit-area'))
          return

        // Fetch raw content from server (admin only action)
        const { data, error } = await actions.comment.getRaw({ rid })
        if (error) {
          return handleActionError(error)
        }

        const raw = (data && data.content) ? data.content : ''

        // Build editor UI
        const editWrapper = document.createElement('div')
        editWrapper.className = 'comment-edit-area mt-2'

        const ta = document.createElement('textarea')
        ta.className = 'form-control comment-edit-textarea'
        ta.rows = 4
        ta.value = raw

        const ctrl = document.createElement('div')
        ctrl.className = 'mt-2 text-end'

        const saveBtn = document.createElement('button')
        saveBtn.type = 'button'
        saveBtn.className = 'btn btn-primary me-2 comment-save-edit'
        saveBtn.textContent = '保存'

        const cancelBtn = document.createElement('button')
        cancelBtn.type = 'button'
        cancelBtn.className = 'btn btn-light comment-cancel-edit'
        cancelBtn.textContent = '取消'

        ctrl.appendChild(saveBtn)
        ctrl.appendChild(cancelBtn)
        editWrapper.appendChild(ta)
        editWrapper.appendChild(ctrl)

        contentEl.appendChild(editWrapper)

        // Cancel handler
        cancelBtn.addEventListener('click', () => {
          editWrapper.remove()
        })

        // Save handler
        saveBtn.addEventListener('click', async () => {
          const originalText = saveBtn.textContent || '保存'
          saveBtn.disabled = true
          saveBtn.textContent = '保存中...'
          try {
            const { data: editData, error: editError } = await actions.comment.edit({ rid, content: ta.value })
            if (editError) {
              saveBtn.disabled = false
              saveBtn.textContent = originalText
              return handleActionError(editError)
            }

            if (editData && editData.content) {
              // Replace the whole comment item with updated HTML
              commentItem.insertAdjacentHTML('afterend', editData.content)
              commentItem.remove()
            }
          }
          catch (e) {
            console.error(e)
            saveBtn.disabled = false
            saveBtn.textContent = originalText
          }
        })
      }
    }

    // Approve a comment.
    if (target.matches('.comment-approve-link')) {
      const rid = (target as HTMLElement).dataset.rid
      if (typeof rid === 'string') {
        const { error } = await actions.comment.approve({ rid })
        if (error) {
          return handleActionError(error)
        }
        else {
          target.remove()
        }
      }
    }

    // Delete a comment.
    if (target.matches('.comment-delete-link')) {
      const rid = (target as HTMLElement).dataset.rid
      if (typeof rid === 'string') {
        const { error } = await actions.comment.delete({ rid })
        if (error) {
          return handleActionError(error)
        }
        else {
          target.closest('li')!.remove()
        }
      }
    }

    // Cancel reply comment.
    if (target === cancel) {
      cancelReply()
    }
  })

  // Reply a comment.
  comments.addEventListener('submit', async (event: Event) => {
    event.preventDefault()
    event.stopPropagation()

    const form = event.target as HTMLFormElement
    const formData = new FormData(form)
    // Build the request object with explicit types
    const name = formData.get('name') as string
    const email = formData.get('email') as string
    const page_key = formData.get('page_key') as string
    const content = formData.get('content') as string
    const link = formData.get('link') as string | null
    const rid = formData.get('rid')
    const request: {
      name: string
      email: string
      page_key: string
      content: string
      link?: string
      rid?: number
    } = {
      name,
      email,
      page_key,
      content,
    }
    if (link)
      request.link = link
    if (rid !== undefined && rid !== null && rid !== '') {
      request.rid = Number(rid)
    }
    else {
      request.rid = 0
    }

    const { data, error } = await actions.comment.replyComment(request)

    if (error) {
      return handleActionError(error)
    }

    const { content: replyContent } = data
    if (request.rid !== 0) {
      replyForm.insertAdjacentHTML('beforebegin', replyContent)
    }
    else {
      const list = comments.querySelector('.comment-list')!
      list.insertAdjacentHTML('afterbegin', replyContent)
    }

    cancelReply()
  })
}
</script>
