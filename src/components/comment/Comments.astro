---
import { joinPaths } from '@astrojs/internal-helpers/path'
import config from '@/blog.config'
import Comment from '@/components/comment/Comment.astro'
import { userSession } from '@/helpers/auth/session'
import { increaseViews, loadComments } from '@/helpers/comment/loader'

// This is a component which loads comments and renders it on server-side.
interface Props {
  commentKey: string
  title: string
}

const { commentKey, title } = Astro.props
const comments = await loadComments(Astro.session, commentKey, title, 0)

// Increase the PV in production environment.
const user = await userSession(Astro.session)
if (user === undefined || !user.admin) {
  await increaseViews(commentKey, title)
}
---

<div id="comments" class="comments pt-5">
  {
    comments != null
      ? (
      <>
        <div class="h5 mb-4 comment-total-count">
          评论 <small class="font-theme text-sm">({comments.count})</small>
        </div>
        <div id="respond" class="comment-respond mb-3 mb-md-4">
          <form method="post" action="/comments/new" id="commentForm" class="comment-form">
            <div class="comment-from-avatar flex-avatar">
              {user?.admin
              ? (
                <img
                  alt="头像"
                  src={joinPaths(import.meta.env.SITE, `/images/avatar/${user.id}.png`)}
                  src={joinPaths(import.meta.env.SITE, `/images/avatar/${user.id}.png`)}
                  class="avatar avatar-40 photo avatar-default"
                  height="40"
                  width="40"
                  decoding="async"
                />
              )
              : (
                <img
                  alt="头像"
                  src={joinPaths(import.meta.env.SITE, '/images/default-avatar.png')}
                  data-src={joinPaths(import.meta.env.SITE, '/images/default-avatar.png')}
                  class="avatar avatar-40 photo avatar-default"
                  height="40"
                  width="40"
                  decoding="async"
                />
              )}
            </div>
            <div class="comment-from-input flex-fill">
              <div class="comment-form-text mb-3">
                <textarea id="content" name="content" class="form-control" rows="3" required />
              </div>
              <div class="comment-form-info row g-2 g-md-3 mb-3">
                {user?.admin
                ? (
                  <input
                    class="form-control"
                    placeholder={user.name}
                    name="name"
                    type="text"
                    readonly
                    hidden
                    value={user.name}
                  />
                )
                : (
                  <div class="col">
                    <input class="form-control" placeholder="昵称" name="name" type="text" required />
                  </div>
                )}
                {user?.admin
                ? (
                  <input
                    class="form-control"
                    name="email"
                    placeholder={user.email}
                    value={user.email}
                    type="email"
                    readonly
                    hidden
                  />
                )
                : (
                  <div class="col-12 col-md-6">
                    <input class="form-control" name="email" placeholder="邮箱" type="email" required />
                  </div>
                )}
                <input hidden name="page_key" type="text" value={commentKey} />
                <input hidden name="rid" type="text" value="0" />
                {user?.admin
                ? (
                  <input
                    class="form-control"
                    placeholder={user.website}
                    value={user.website}
                    name="link"
                    type="url"
                    readonly
                    hidden
                  />
                )
                : (
                  <div class="col-12">
                    <input class="form-control" placeholder="网址" name="link" type="url" />
                  </div>
                )}
              </div>
              <div class="form-submit text-end">
                <input type="button" id="cancel-comment-reply-link" class="btn btn-light me-1" value="再想想" hidden />
                <input name="submit" type="submit" id="submit" class="btn btn-primary" value="发表评论" />
              </div>
            </div>
          </form>
        </div>
        <ul class="comment-list">
          <Comment comments={comments} session={Astro.session} />
        </ul>
        {config.settings.comments.size < comments.roots_count && (
          <div class="text-center mt-3 mt-md-4">
            <button
              id="comments-next-button"
              data-key={commentKey}
              data-size={config.settings.comments.size}
              data-offset={config.settings.comments.size}
              type="button"
              class="btn btn-light"
            >
              加载更多
            </button>
          </div>
        )}
      </>
    )
    : (
      '评论加载失败 ❌'
    )
  }
</div>

<script>
import { actions } from 'astro:actions'
import { handleActionError } from '@/assets/scripts/actions'

// Type helpers
type Nullable<T> = T | null

// Loading the comments.
const comments = document.querySelector<HTMLDivElement>('#comments')
if (typeof comments !== 'undefined' && comments !== null) {
  const cancel = comments.querySelector<HTMLInputElement>('#cancel-comment-reply-link')!
  const replyForm = comments.querySelector<HTMLDivElement>('#respond')!
  const cancelReply = (): void => {
    cancel.hidden = true;
    (replyForm.querySelector('textarea[name="content"]') as HTMLTextAreaElement).value = ''

    // Remove the readonly replying-to prefix or overlay if present and restore padding
    const replyingTo = replyForm.querySelector('.replying-to, .replying-to-overlay')
    if (replyingTo) {
      // If it's an overlay, restore textarea padding and remove event listeners
      if (replyingTo.classList.contains('replying-to-overlay')) {
        const formText = replyForm.querySelector<HTMLDivElement>('.comment-form-text')!
        const textarea = formText.querySelector<HTMLTextAreaElement>('textarea[name="content"]')!
        const orig = textarea.dataset._origPaddingTop || ''
        textarea.style.paddingTop = orig
        delete textarea.dataset._origPaddingTop

        // Remove attached handlers
        const onFocus = (textarea as any).__replyOverlayFocus
        const onBlur = (textarea as any).__replyOverlayBlur
        if (onFocus)
          textarea.removeEventListener('focus', onFocus)
        if (onBlur)
          textarea.removeEventListener('blur', onBlur)
        delete (textarea as any).__replyOverlayFocus
        delete (textarea as any).__replyOverlayBlur
      }
      replyingTo.remove()
    }

    // Move the form back to top.
    const commentCount = comments.querySelector('.comment-total-count')!
    commentCount.after(replyForm)

    // Get rid to clean up the children form.
    const ridInput = replyForm.querySelector<HTMLInputElement>('input[name="rid"]')!
    const rid = ridInput.value
    ridInput.value = '0'
    if (rid !== '0') {
      const userComment = comments.querySelector(`#user-comment-${rid}`) as Nullable<HTMLLIElement>
      if (userComment) {
        const children = userComment.querySelector('.children') as Nullable<HTMLUListElement>
        if (children !== null && children.querySelectorAll('li').length === 0) {
          children.remove()
        }
      }
    }
  }

  comments.addEventListener('focusout', (event: FocusEvent) => {
    const avatar = document.querySelector<HTMLImageElement>('#commentForm img.avatar')
    const emailInput = document.querySelector<HTMLInputElement>('input[name="email"]')
    if (event.target === emailInput && avatar && emailInput) {
      event.stopPropagation()
      const email = emailInput.value
      if (email !== '' && email.includes('@')) {
        // Replace the avatar after typing the email.
        actions.comment.findAvatar({ email }).then(({ data, error }: any) => {
          if (error) {
            return handleActionError(error)
          }
          avatar.src = data.avatar
        })
      }
      else {
        avatar.src = avatar.dataset.src!
      }
    }
  })

  comments.addEventListener('click', async (event: MouseEvent) => {
    const target = event.target as HTMLElement
    // Loading more comments from server.
    const nextButton = comments.querySelector('#comments-next-button')
    if (target === nextButton) {
      const { size, offset, key } = (target as HTMLButtonElement).dataset
      if (typeof key === 'string' && typeof offset === 'string' && typeof size === 'string') {
        const { data, error } = await actions.comment.loadComments({ offset: Number(offset), page_key: key })
        if (error) {
          return handleActionError(error)
        }

        const { content, next } = data

        // Remove the load more button.
        if (!next || content === '') {
          target.remove()
        }

        // Append the comments into the list.
        if (content !== '') {
          (target as HTMLButtonElement).dataset.offset = String(Number(offset) + Number(size))
          comments.querySelector('.comment-list')!.insertAdjacentHTML('beforeend', content)
        }
      }
    }

    // Reply a comment.
    if (target.matches('.comment-reply-link')) {
      cancelReply()
      cancel.hidden = false;
      (replyForm.querySelector('input[name="rid"]') as HTMLInputElement).value = (target as HTMLElement).dataset.rid!

      // Move form to the reply.
      const commentItem = target.closest('li') as HTMLLIElement
      if (commentItem.dataset.depth === '1') {
        if (commentItem.querySelector('ul.children') === null) {
          // Create this for better architecture.
          commentItem.insertAdjacentHTML('beforeend', '<ul class="children"></ul>')
        }
        commentItem.querySelector('ul.children')!.appendChild(replyForm)
      }
      else {
        commentItem.after(replyForm)
      }

      // Extract the author name and content from the comment
      let authorName = ''
      let originalContent = ''
      const authorEl = commentItem.querySelector('.comment-author') as HTMLElement | null
      const contentEl = commentItem.querySelector('.comment-content') as HTMLElement | null

      if (authorEl) {
        const anchor = authorEl.querySelector('a') as HTMLAnchorElement | null
        if (anchor && anchor.textContent) {
          authorName = anchor.textContent.trim()
        }
        else {
          const textNode = Array.from(authorEl.childNodes).find(n => n.nodeType === Node.TEXT_NODE && n.textContent && n.textContent.trim())
          authorName = (textNode && textNode.textContent) ? textNode.textContent.trim() : (authorEl.textContent || '').trim()
        }
      }

      if (contentEl) {
        originalContent = contentEl.textContent?.trim() || ''
      }

      // Remove any existing prefix/overlay then insert new one
      const existingPrefix = replyForm.querySelector('.replying-to, .replying-to-overlay')
      if (existingPrefix)
        existingPrefix.remove()
      if (authorName) {
        const formText = replyForm.querySelector<HTMLDivElement>('.comment-form-text')!
        const textarea = formText.querySelector<HTMLTextAreaElement>('textarea[name="content"]')!

        // Create an overlay element that floats inside the textarea area.
        const overlay = document.createElement('div')
        overlay.className = 'replying-to-overlay'

        // Create spans for the name and content parts for better styling
        const nameSpan = document.createElement('span')
        nameSpan.className = 'replying-name'
        nameSpan.textContent = `回复 @${authorName}`

        const contentSpan = document.createElement('span')
        contentSpan.className = 'replying-content'
        contentSpan.textContent = originalContent ? `: ${originalContent}` : ''

        overlay.appendChild(nameSpan)
        overlay.appendChild(contentSpan)
        Object.assign(overlay.style, {
          position: 'absolute',
          top: '0.4rem',
          left: '0.75rem',
          right: '0.75rem',
          fontSize: '0.9rem',
          color: 'rgba(108,117,125,0.9)',
          pointerEvents: 'none',
          background: 'transparent',
          zIndex: '2',
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          display: 'flex',
          gap: '0.25rem',
          alignItems: 'center',
        })

        // Ensure the container is positioned so the overlay can be absolutely positioned.
        const formTextEl = formText as HTMLElement
        if (!formTextEl.style.position)
          formTextEl.style.position = 'relative'

        // Remember and increase textarea paddingTop so content doesn't overlap the overlay.
        const prevPaddingTop = textarea.style.paddingTop || window.getComputedStyle(textarea).paddingTop || ''
        textarea.dataset._origPaddingTop = prevPaddingTop
        textarea.style.paddingTop = '2rem'

        // Store handlers for focus/blur effects
        function onFocus() {
          overlay.style.opacity = '0.6'
        }
        function onBlur() {
          overlay.style.opacity = '1'
        }
        textarea.addEventListener('focus', onFocus)
        textarea.addEventListener('blur', onBlur)
        ;(textarea as any).__replyOverlayFocus = onFocus
        ;(textarea as any).__replyOverlayBlur = onBlur

        formText.appendChild(overlay)
      }

      // Focus the comment form.
      (replyForm.querySelector('#content') as HTMLTextAreaElement).focus()
    }

    // Approve a comment.
    if (target.matches('.comment-approve-link')) {
      const rid = (target as HTMLElement).dataset.rid
      if (typeof rid === 'string') {
        const { error } = await actions.comment.approve({ rid })
        if (error) {
          return handleActionError(error)
        }
        else {
          target.remove()
        }
      }
    }

    // Delete a comment.
    if (target.matches('.comment-delete-link')) {
      const rid = (target as HTMLElement).dataset.rid
      if (typeof rid === 'string') {
        const { error } = await actions.comment.delete({ rid })
        if (error) {
          return handleActionError(error)
        }
        else {
          target.closest('li')!.remove()
        }
      }
    }

    // Cancel reply comment.
    if (target === cancel) {
      cancelReply()
    }
  })

  // Reply a comment.
  comments.addEventListener('submit', async (event: Event) => {
    event.preventDefault()
    event.stopPropagation()

    const form = event.target as HTMLFormElement
    const formData = new FormData(form)
    // Build the request object with explicit types
    const name = formData.get('name') as string
    const email = formData.get('email') as string
    const page_key = formData.get('page_key') as string
    const content = formData.get('content') as string
    const link = formData.get('link') as string | null
    const rid = formData.get('rid')
    const request: {
      name: string
      email: string
      page_key: string
      content: string
      link?: string
      rid?: number
    } = {
      name,
      email,
      page_key,
      content,
    }
    if (link)
      request.link = link
    if (rid !== undefined && rid !== null && rid !== '') {
      request.rid = Number(rid)
    }
    else {
      request.rid = 0
    }

    const { data, error } = await actions.comment.replyComment(request)

    if (error) {
      return handleActionError(error)
    }

    const { content: replyContent } = data
    if (request.rid !== 0) {
      replyForm.insertAdjacentHTML('beforebegin', replyContent)
    }
    else {
      const list = comments.querySelector('.comment-list')!
      list.insertAdjacentHTML('afterbegin', replyContent)
    }

    cancelReply()
  })
}
</script>
